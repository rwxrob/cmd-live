#!/bin/bash
# shellcheck disable=SC2016
# https://github.com/rwxrob/template-bash-command.
set -e
#set -x

(( BASH_VERSINFO[0] < 4 )) && echo "Bash 4+ required." && exit 1

: "${PAGER:=more}"
: "${EDITOR:=vi}"
: "${HELP_BROWSER:=}"
: "${EXE:="${0##*/}"}"

declare -A HELP
declare -A CONF

declare black="\e[30m"
declare red="\e[31m"
declare green="\e[32m"
declare yellow="\e[33m"
declare blue="\e[34m"
declare magenta="\e[35m"
declare cyan="\e[36m"
declare white="\e[37m"
declare reset="\e[0m"

declare -a colors=($black $red $green $yellow $blue $magenta $cyan $white)

_initialize() {
  : "${CONF[current]:=away}"
  : "${CONF[maxstatus]:=32}"
  COMMANDS+=($(x.list.modes))
  COMMANDS+=(name emojis titles)
}

_alternatives() {

  if [[ -z "$CMD" ]];then
    x.title "$@"
    return $?
  fi

  local modecmds=$(x.list.modes)
  modecmds=${modecmds// /|}
  if [[ $CMD =~ ^$modecmds$ ]]; then
    x.mode "$CMD"
    return $?
  fi

  if [[ $CMD == name ]]; then
    x.mode "$@"
    return $?
  fi

  if [[ $CMD == titles ]]; then
    x.list.titles
    return $?
  fi

  if [[ $CMD == emojis ]]; then
    x.list.emojis
    return $?
  fi

}

HELP[main]='
# Live Streaming Mode and Status Update Utility

This bash script helps Twitch live streamers use the command line to
keep their communities informed about what is happening on their stream in
real time by communicating the change in status using profiles for their
current "mode". It can also send notifications using other methods
(depending on what is detected and supported on the current system):

* Twitch Title
* Twitch Category
* Twitch Chat Message
* Twitter Post
* GitHub Status

## Dependencies

Required:

* Bash 4+
* `curl`
* `jq`

Optional:

* `pandoc` - for rich help docs

## Security

This script is expected to be installed for a specific user and only
ever run by that user. No additional security vetting for running as an
untrusted user has been done.

## Legal

Copyright 2021 Rob Muhlestein <rob@rwx.gg>  
Released under Apache-2.0 License  
Please mention rwxrob.tv'

# ---------------------------- list.modes ----------------------------

HELP[list.modes]='List available modes.'

x.list.modes () {
  local -a modes
  local mode line
  while IFS= read -r line; do
    if [[ $line =~ ^mode && $line =~ name ]]; then
      line=${line//mode./}
      mode=${line//.name/}
      modes+=($mode)
    fi
  done < <(x.config keys);
  if [[ -t 1 ]]; then
    for mode in $(printf "%s\n" "${modes[@]}" | sort ); do
      echo -en "${colors[((RANDOM%8))]}$mode$reset "
    done
  else
    mapfile -t buf < <(printf "%s\n" "${modes[@]}" | sort)
    echo "${buf[@]}"
  fi
  echo
}

# ------------------------------- mode -------------------------------

HELP[mode]='

```
'"$EXE"' [NEW]
```

Print the current mode name (from local cache) or set to a new one. Note
that this does not fetch the current remote Twitch status'

x.mode() { x.config current "$@";}

# ------------------------------- emoji ------------------------------

HELP[emoji]='

```
'"$EXE"' [NEW]
```

Print or change the current mode emoji.'

x.emoji() {
  local cur="$(x.mode)" new="$1"
  if [[ -z "$new" ]]; then
    x.config "mode.$cur.emoji"
    return $?
  fi
  x.config "mode.$cur.emoji" "$new"
}

# ---------------------------- list.titles ---------------------------

HELP[list.titles]='

```
'"$EXE"'
```

List all titles in alphabetical order by mode name.'

x.list.titles() {
  local cur="$(x.mode)"
  for i in $(x.list.modes); do
    x.mode "$i"
    printf "%s\n" "$(x.title)"
  done
  x.mode "$cur"
}

# --------------------------- titles.modes ---------------------------

HELP[titles.modes]='

```
'"$EXE"'
```

List all titles in alphabetical order by mode name and show mode.'

x.titles.modes() {
  local cur="$(x.mode)"
  for i in $(x.list.modes); do
    x.mode "$i"
    printf "%s [%s]\n" "$(x.title)" "$i"
  done
  x.mode "$cur"
}

# ----------------------- _check_status_length -----------------------

_check_status_length() {
  local max="$(x.config maxstatus)"
  local new="$1"
  if (( ${#new} > max )); then
    printf "WARNING: status is longer than %s\n" "$max"
  fi
}

# ------------------------------ status ------------------------------

HELP[status]='

```
'"$EXE"' [NEW]
```

Print or change the current status (overrides status.default for current
mode).  '

x.status() {
  local  new="$*" cur="$(x.mode)"
  if [[ -z "$new" ]]; then
    local status="$(x.config "mode.$cur.status")"
    if [[ -z "$status" ]]; then
      x.status.default
      return $?
    fi
    echo "$status"
    return $?
  fi
  _check_status_length "$new"
  x.config "mode.$cur.status" "$new"
}

# --------------------------- status.clear ---------------------------

HELP[status.clear]='

```
'"$EXE"'
```

Clears the current status (switching to status.default).'

x.status.clear() {
  local cur="$(x.mode)"
  x.config delete "mode.$cur.status"
}

# -------------------------- status.default --------------------------

HELP[status.default]='

```
'"$EXE"' [NEW]
```

Print or change the current mode status default. (See status also.)
'

x.status.default() {
  local cur="$(x.mode)" new="$*"
  if [[ -z "$new" ]]; then
    x.config "mode.$cur.status.default"
    return $?
  fi
  x.config "mode.$cur.status.default" "$new"
}

# ----------------------------- category -----------------------------

HELP[category]='

```
'"$EXE"' [NEW]
```

Print or change the current mode category. Prints both the category ID
number and the long written form separated by a space. Note that
changing the category requires the number only and does not immediately
update the current category on Twitch, only the local entry in the
configuration data.'

x.category() {
  local cur="$(x.mode)" new="$*"
  if [[ -z "$new" ]]; then
    local id="$(x.config "mode.$cur.category")"
    local long="$(x.config "cat.$id")"
    printf "%s %s\n" "$id" "$long"
    return $?
  fi
  x.config "mode.$cur.category" "$new"
}

# -------------------------- list.categories -------------------------

HELP[list.categories]='List available categories.'

x.list.categories () {
  local -A ids
  local line id name
  while IFS= read -r line; do
    if [[ $line =~ ^cat ]]; then
      id=${line##*.}
      name=$(x.config "cat.$id")
      ids["$name"]=$id
    fi
  done < <(x.config keys);
  while IFS= read -r name; do
    printf "$white%10s$reset $blue%s$reset\n" "${ids[$name]}" "$name"
  done < <(printf "%s\n" "${!ids[@]}" | sort)
}

# ----------------------------- list.tags ----------------------------

HELP[list.tags]='List available tags.'

x.list.tags () {
  local -a tags
  local line tag
  while IFS= read -r line; do
    if [[ $line =~ ^tag ]]; then
      tags+=(${line##*.})
    fi
  done < <(x.config keys);
  while IFS= read -r tag; do
    echo -ne "${colors[((RANDOM%8))]}$tag$reset "
  done < <(printf "%s\n" "${tags[@]}" | sort)
  echo
}

# ---------------------------- list.emojis ---------------------------

HELP[list.emojis]='List emojis from all modes'

x.list.emojis () {
  local line
  while IFS= read -r line; do
    if [[ $line =~ .emoji= ]]; then
      echo -n "${line##*=}  "
    fi
  done < "$(x.config path)";
  echo
}

# ------------------------------- tags -------------------------------

HELP[tags]='

```
'"$EXE"' [NEW]
```

Print or change the current tags list. Note that changing the tags does
not update the current tags on Twitch, only the local entry in the
configuration data. Twitch limits tags to five total.'

x.tags() {
  local cur="$(x.mode)" new="$*"
  if [[ -z "$new" ]]; then
    x.config "mode.$cur.tags"
    return $?
  fi
  x.config "mode.$cur.tags" "$new"
}

# ------------------------------- title ------------------------------

HELP[title]='

```
'"$EXE"'
```

Print the current emoji, mode, status, and flags on a single line
suitable for pasting into the Twitch Stream Info > Title field.  The
commas of the flags will be replaced with bars (|) and wrapped with
square brackets. Will use either the current status or the
default.status for the current mode if not set.'

x.title() {
  local status=$(x.status)
  printf "%s %s\n" \
    "$(x.emoji)" \
    "$status"
}

# ------------------------------ delete ------------------------------

HELP[delete]='

```
'"$EXE"' MODE
```

Delete all data for a specific. WARNING: Does not ask for confirmation.
'

x.delete() {
  local cur="$1"
  [[ -z "$cur" ]] && echo "Must specify mode to delete" && return 1
  x.config delete "mode.$cur.emoji"
  x.config delete "mode.$cur.name"
  x.config delete "mode.$cur.status"
  x.config delete "mode.$cur.status.default"
  x.config delete "mode.$cur.flags"
  x.config delete "mode.$cur.category"
  echo "Deleted $cur"
}

# -------------------------- utility command -------------------------

HELP[usage]='Displays a summary of usage.'

x.usage() {
  local -a cmds
  for c in "${COMMANDS[@]}"; do
    [[ ${c:0:1} =~ _ ]] && continue
    cmds+=("$c")
  done
  local IFS='|'
  printf "usage: %s (%s)\n" "$EXE" "${cmds[*]}"
}

# --------------------------- help command ---------------------------

HELP[help]='

```
'"$EXE"' help [COMMAND]
```

Displays specific help information. If no argument is passed displays
general help information (main). Otherwise, the documentation for the
specific argument keyword is displayed, which usually corresponds to
a COMMAND name (but not necessarily). All documentation is written in
GitHub Flavored Markdown and will displayed as a web page if `pandoc`
and `$HELP_BROWSER` are detected, otherwise, just the Markdown is sent
to `$PAGER` (default: more).

Also see `readme` and `usage` commands.
'

x.help() { 
  local name="${1:-main}" title body
  title=$(_help_title "$name") || true
  if [[ -z "$title" ]]; then
    body="${HELP[$name]}"
    title="$EXE $name"
    [[ $name = main ]] && title="$EXE"
  else
    body="${HELP[$name]}"
    body=${body#*$title}
  fi
  local file="/tmp/help-$EXE-$name.html"
  if _have pandoc ; then
    if _have "$HELP_BROWSER" && [[ -t 1 ]] ;then
      pandoc -f gfm -s --metadata title="$title" \
        -o "$file" <<< "$body"
      [[ -z "$2" ]] && cd /tmp && exec "$HELP_BROWSER" "$file"
      return 0
    fi
    pandoc -f gfm -s --metadata title="$title" \
      -t plain <<< "$body" | "$PAGER"
    return 0
  fi
  echo -e "$title\n\n$body" | "$PAGER"
}

_help_title() {
  _filter "$@" && return $?;
  local name="$1"
  while IFS= read -r line; do
    [[ $line =~ ^[:space]*$ ]] && continue
    [[ $line =~ ^#\ (.+) ]] && echo "${BASH_REMATCH[1]}" && return 0
    return 1
  done <<< "${HELP[$name]}"
}

# -------------------------- readme command --------------------------

HELP[readme]='
## Generate `README.md` File

```
'"$EXE"' readme > README.md
```

The `readme` command will output the embedded help documentation in raw
GitHub Flavored Markdown suitable for use as a `README.md` file on
GitHub or similar hosting service.'

x.readme() {
  _trim "${HELP[main]}"
  echo
  while IFS= read -r name; do
    [[ $name = main ]] && continue
    body=$(_trim "${HELP[$name]}")
    [[ $body =~ ^\# ]] || body="## The \`$name\` Command"$'\n\n'$body
    printf "%s\n\n" "$body"
  done < <(printf "%s\n" "${!HELP[@]}" | LC_COLLATE=C sort)
  echo -e "----\n\n*Autogenerated $(date)*\n"
}

# x.json() { _jsonstr "$@"; }
# x.urlencode() { _urlencode "$@"; }


# -------------------------- config command --------------------------

HELP[config]='

```
'"$EXE"' config
'"$EXE"' config KEY
'"$EXE"' config KEY VALUE
'"$EXE"' config KEY ""
'"$EXE"' config keys
'"$EXE"' config val[ues]
'"$EXE"' config dir[ectory]
'"$EXE"' config path [file]
'"$EXE"' config edit [file]
'"$EXE"' config del[ete]
```

The `config` command is for reading, writing, and displaying standard
open desktop configuration properties. Pass an empty string to delete
a property.

### Arguments

With no arguments outputs all the currently cached configuration
settings.

With a single KEY argument fetches the value for that key and outputs
it unless it is one of the following special (reserved) key names:

* `dir*` full path to config directory
* `path` full path to specific config file (default: `values`) 
* `edit` opens config file in editor (default: `editor` or `$EDITOR)
* `keys` output the configuration keys, one per line
* `val*` output the configuration values, one per line
* `del*` if key argument then delete a specific key, otherwise prompt

With more than one argument the remaining arguments after the KEY will
be combined into the VALUE and written to a `values` file in the
configuration directory. 

### Configuration Directory

The configuration directory path relies on the following environment
variables:

* `EXE` - defaults to name of currently running command ('"$EXE"')
* `HOME` - checked for `$HOME/.config/$EXE/values`
* `XDG_CONFIG_HOME` - overrides `$HOME/.config`
* `CONFIG_DIR` - full path to directory containing `values` file

The `CONFIG_DIR` always takes priority over anything else if set, but is
never implied. If the directory does not exist it will be created the
first time a value is set.

### Configuration `values` File Format

The file (which is almost always located at
`~/.config/'"$EXE"'/values`) uses the simplest possible format to
facilitate standard UNIX parsing and filtering with any number of
existing tools (and no `jq` dependency).

* One KEY=VALUE per line
* KEYs may be anything but the equal sign (`=`)
* VALUEs may be anything but line returns must be escaped

Note that this is *not* the same as Java properties and other similar
format. It is designed for ultimate simplicity, efficiency, and
portability.'

x.config() {
  case $1 in 
    dir*) shift; _config_dir  "$@"; return $? ;;
    path) shift; _config_path "$@"; return $? ;;
    edit) shift; _config_edit "$@"; return $? ;;
    del*) shift; _config_del  "$@"; return $? ;;
    keys) shift; _config_keys "$@"; return $? ;;
    val*) shift; _config_vals "$@"; return $? ;;
  esac
  case $# in
    0) _config_dump ;;
    1) _config_get "$@" ;;
    *) _config_set "$@" ;;
  esac
}

_config_edit() {
  : "${CONF[editor]:="${EDITOR:=vi}"}"
  exec "${CONF[editor]}" "$(_config_path "${1:-values}")"
}

_config_del() {
  if [[ -z "$1" ]];then
    select key in "${!CONF[@]}"; do
      _config_del "$key"
      return $? 
    done
  fi
  _config_set "$1" ''
}

_config_keys() { printf "%s\n" "${!CONF[@]}"; }

_config_vals() { printf "%s\n" "${CONF[@]}"; }

_config_dir() {
  local dir="$HOME/.config/$EXE"
  [[ -n "$XDG_CONFIG_HOME" ]] && dir="$XDG_CONFIG_HOME/$EXE" 
  [[ -n "$CONFIG_DIR" ]] && dir="$CONFIG_DIR"
  [[ -n "$1" ]] && echo "$dir/$1" && return 0
  printf "%s" "$dir"
  [[ -t 1 ]] && echo
  return 0
}

_config_path() { 
  local file=${1:-values}
  printf "%s/%s" "$(_config_dir)" "$file"
  [[ -t 1 ]] && echo
  return 0
}

_config_set() {
  local key="$1"; shift; local val="$*"
  val="${val//$'\n'/\\n}"
  CONF["$key"]="$val"
  _config_write
}

_config_get() { 
  printf "%s" "${CONF[$1]}"
  [[ -t 1 ]] && echo
  return 0
}

_config_read() {
  local values="$(_config_path)"
  [[ -r "$values" ]] || return 0
  while IFS= read -r line; do
    [[ $line =~ ^([^=]+)=(.+)$ ]] || continue
    CONF["${BASH_REMATCH[1]}"]="${BASH_REMATCH[2]}"
  done < "$values"
}

_config_write() {
  local dir="$(_config_dir)"
  mkdir -p "$dir"
  _config_dump > "$dir/values"
}

_config_dump() {
  (( ${#CONF[@]} == 0 )) && return 0
  paste -d=\
    <(printf "%s\n" "${!CONF[@]}") \
    <(printf "%s\n" "${CONF[@]}") \
  | sort
}

# ----------------------------- utilities ----------------------------

_jsonstr() {
  _checkdep jq || return $?
  _buffer "$@" && return $?
  jq -MRsc <<< "$1"
}

_urlencode() {
  _buffer "$@" && return $?
  local string="$1"
  local strlen=${#string}
  local encoded=""
  local pos c o
  for ((pos = 0; pos < strlen; pos++)); do
    c=${string:$pos:1}
    case "$c" in
    [-_.~a-zA-Z0-9]) o="$c" ;;
    *) printf -v o '%%%02x' "'$c'" ;;
    esac
    encoded+="$o"
  done
  echo "$encoded"
}

_reduce() {
  local -n name="${1:?"name of array required"}"
  while IFS= read -r key; do
    [[ $key =~ $2 ]] && echo "$key"
  done < <(printf "%s\n" "${name[@]}")
}

_newest() {
  IFS=$'\n'
  mapfile -t f < <(ls -1 --color=never -trd "${1:-.}"/* 2>/dev/null)
  [[ ${#f} > 0 ]] && echo "${f[-1]}"
}

_trim() {
  local it="${1#"${1%%[![:space:]]*}"}"
  echo -e "${it%"${it##*[![:space:]]}"}"
}

_have(){ type "$1" &>/dev/null; }

_checkdep() {
  _have "$1" && return 0
  echo "'$EXE' depends on '$1' for this, but not found"
  return 1
}

_filter(){
  [[ -n "$1" ]] && return 1
  while IFS= read -ra args; do
    "${FUNCNAME[1]}" "${args[@]}"
  done
}

_buffer() {
  [[ -n "$1" ]] && return 1
  "${FUNCNAME[1]}" "$(</dev/stdin)"
}

# --------------------- completion and delegation --------------------
#      `complete -C foo foo` > `source <(foo bloated_completion)`

_config_read
_have _initialize && _initialize "$@"

while IFS= read -r line; do
  [[ $line =~ ^declare\ -f\ x\. ]] || continue
  COMMANDS+=( "${line##declare -f x.}" )
done < <(declare -F)
mapfile -t COMMANDS < \
  <(LC_COLLATE=C sort < <(printf "%s\n" "${COMMANDS[@]}"))

if [[ -n $COMP_LINE ]]; then
  line=${COMP_LINE#* }
  for c in "${COMMANDS[@]}"; do
    [[ ${c:0:${#line}} == "${line,,}" ]] && echo "$c"
  done
  exit
fi

for c in "${COMMANDS[@]}"; do
  if [[ $c == "$EXE" ]]; then
    "x.$EXE" "$@"
    exit $?
  fi
done

if [[ -n "$1" ]]; then
  declare CMD="$1"; shift
  for c in "${COMMANDS[@]}"; do
    declare cmd=$(command -v "x.$c")
    if [[ $c == "$CMD" && -n "$cmd" ]]; then
      "x.$CMD" "$@"
      exit $?
    fi
  done
fi

if _have _alternatives; then
  _alternatives "$@" 
  exit $?
fi

x.usage "$@"
